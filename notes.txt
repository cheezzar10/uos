starting UOS image using qemu

$ qemu-system-i386 -m 1 -display curses -fda uos.img -no-fd-bootchk -boot order=a

the same as above but with hard disk installed

$ qemu-system-i386 -m 1 -display curses -fda uos.img -hda hda.img -no-fd-bootchk -boot order=a

loader.s and loader.c are the second stage loader files which will configure paging and pass control
the core of the system written in Rust

disassembly of loader code

tail -c ++513 loader.bin > loader.bin.code
objdump -D -bbinary -mi386 loader.bin

one possible task switch design: 

1. yield implemented as assembly gate
2. it has access to pointers cur_task, next_task. This pointers are defined in assembly and referenced as extern
3. yeild calls software interrupt ( performs syscall actually )

saving current task state in it's task state structure ( pushad and then performing copy )
calling scheduler_switch_task

this function retrieves next task using scheduler_get_next_task and stores pointer to current task state structure ( not yet switched )
returning to assembly code, performing to be switched task state copy on stack, performing popad, placing stored eip and flags on interrupt processing stack
performing iret


getting pointer to the next runnable task using scheduler_get_next_task()
